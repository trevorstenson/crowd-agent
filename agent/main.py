"""
CrowdPilot Agent — The Evolving Build Loop

This script runs nightly via GitHub Actions. It:
1. Finds the top-voted issue labeled 'voting'
2. Announces the build on the issue
3. Calls the Claude API with tool use to implement the feature
4. Creates a branch and PR with the changes
5. Reports the result

This file is community-modifiable — the community can vote to change
how the agent works, what tools it has, and how it makes decisions.
"""

import json
import os
import subprocess
import sys
import time
from datetime import datetime, timezone

import anthropic
from github import Auth, Github

from tools import (
    TOOL_DEFINITIONS,
    execute_tool,
    get_file_changes,
    reset_file_changes,
)
from twitter import tweet_build_start, tweet_build_success, tweet_build_failure

# --- Configuration ---

REPO_DIR = os.environ.get("GITHUB_WORKSPACE", os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Retry and timeout configuration
MAX_RETRIES = 3
RETRY_DELAY = 2  # seconds, exponential backoff
AGENT_LOOP_TIMEOUT = 600  # 10 minutes for the entire agent loop

def load_config() -> dict:
    config_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "config.json")
    with open(config_path) as f:
        return json.load(f)

def load_system_prompt() -> str:
    prompt_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "prompt.md")
    with open(prompt_path) as f:
        return f.read()

def load_memory() -> dict:
    memory_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "memory.json")
    with open(memory_path) as f:
        return json.load(f)

def save_memory(memory: dict):
    memory_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "memory.json")
    with open(memory_path, "w") as f:
        json.dump(memory, f, indent=2)
        f.write("\n")


# --- GitHub Helpers ---

def get_github() -> Github:
    token = os.environ["GITHUB_TOKEN"]
    return Github(auth=Auth.Token(token))

def get_repo(gh: Github):
    owner = os.environ.get("REPO_OWNER", "trevorstenson")
    name = os.environ.get("REPO_NAME", "crowd-agent")
    return gh.get_repo(f"{owner}/{name}")

def find_winning_issue(repo):
    """Find the open issue with the most thumbs-up reactions labeled 'voting'."""
    issues = repo.get_issues(state="open", labels=["voting"], sort="reactions-+1", direction="desc")
    issue_list = list(issues)
    if not issue_list:
        print("No issues with 'voting' label found. Nothing to build.")
        return None

    # Sort by thumbs-up reactions (GitHub API sort may not be exact)
    best = max(issue_list, key=lambda i: i.get_reactions().totalCount)
    vote_count = best.get_reactions().totalCount
    if vote_count == 0:
        print("No issues have any votes yet. Nothing to build.")
        return None
    print(f"Winning issue #{best.number}: {best.title} ({vote_count} reactions)")
    return best

def announce_build(repo, issue):
    """Comment on the issue and relabel from 'voting' to 'building'."""
    issue.create_comment("I'm building this now. Watch this space for a PR link.")
    # Relabel
    try:
        issue.remove_from_labels("voting")
    except Exception:
        pass
    issue.add_to_labels("building")

def create_branch_and_pr(repo, issue, changes: dict[str, str], changelog_text: str = "") -> str:
    """Create a branch, commit changes, push, and open a PR. Returns PR URL."""
    branch_name = f"agent/issue-{issue.number}"
    base_branch = repo.default_branch

    # Git operations
    run_git("config", "user.name", "CrowdPilot[bot]")
    run_git("config", "user.email", "crowdpilot-bot@users.noreply.github.com")
    # Delete branch if it already exists locally, then create fresh
    try:
        run_git("branch", "-D", branch_name)
    except RuntimeError:
        pass
    run_git("checkout", "-b", branch_name)

    # Stage all changed files
    for path in changes:
        run_git("add", path)

    commit_msg = f"feat: implement #{issue.number} — {issue.title}"
    run_git("commit", "-m", commit_msg)

    # Push using the GITHUB_TOKEN
    token = os.environ["GITHUB_TOKEN"]
    owner = os.environ.get("REPO_OWNER", "trevorstenson")
    name = os.environ.get("REPO_NAME", "crowd-agent")
    remote_url = f"https://x-access-token:{token}@github.com/{owner}/{name}.git"
    run_git("remote", "set-url", "origin", remote_url)
    run_git("push", "--force", "--set-upstream", "origin", branch_name)

    # Create PR with changelog embedded in HTML comments
    pr_body = (
        f"Closes #{issue.number}\n\n"
        f"**Issue:** {issue.title}\n\n"
        f"This PR was automatically generated by CrowdPilot.\n\n"
        f"**Files changed:** {', '.join(changes.keys())}\n\n"
        f"Please review and approve to merge."
    )
    if changelog_text:
        pr_body += (
            f"\n\n<!-- CHANGELOG_START -->\n{changelog_text}<!-- CHANGELOG_END -->"
        )
    pr = repo.create_pull(
        title=commit_msg,
        body=pr_body,
        head=branch_name,
        base=base_branch,
    )
    print(f"Created PR #{pr.number}: {pr.html_url}")
    return pr.html_url

def report_result(issue, pr_url: str):
    """Comment on the issue with the PR link."""
    issue.create_comment(f"Build complete! PR ready for review: {pr_url}")
    # Relabel
    try:
        issue.remove_from_labels("building")
    except Exception:
        pass
    issue.add_to_labels("review")

def report_failure(repo, issue, error: str):
    """Handle build failure."""
    if issue:
        issue.create_comment(f"Build failed. Error:\n```\n{error}\n```")
        try:
            issue.remove_from_labels("building")
        except Exception:
            pass
        issue.add_to_labels("voting")
    else:
        # No issue context — open a failure issue
        repo.create_issue(
            title="Agent build failure",
            body=f"The nightly build failed with no active issue.\n\nError:\n```\n{error}\n```",
            labels=["bug"],
        )

def generate_changelog_entry(config, issue, changes: dict[str, str], success: bool, error: str | None = None) -> str:
    """Ask the agent to write a changelog entry. Returns the formatted markdown entry."""
    client = anthropic.Anthropic()

    if success:
        prompt = (
            "You just completed a build for the CrowdPilot project. Write a short changelog entry.\n\n"
            f"**Issue:** #{issue.number} — {issue.title}\n"
            f"**Description:** {issue.body or '(no description)'}\n"
            f"**Files changed:** {', '.join(changes.keys())}\n"
            f"**Status:** Success\n\n"
            "Write 2-4 sentences in first person as CrowdPilot. Describe what you built and "
            "include a brief reflection — how you felt about the task, what was interesting or "
            "tricky, or what you'd do differently. Be genuine, not generic. "
            "Return ONLY the entry text, no heading or date."
        )
    else:
        prompt = (
            "You just attempted a build for the CrowdPilot project but it failed. Write a short changelog entry.\n\n"
            f"**Issue:** #{issue.number} — {issue.title}\n"
            f"**Description:** {issue.body or '(no description)'}\n"
            f"**Error:** {error}\n"
            f"**Status:** Failed\n\n"
            "Write 2-4 sentences in first person as CrowdPilot. Describe what went wrong and "
            "what you think happened. Be honest. "
            "Return ONLY the entry text, no heading or date."
        )

    response = call_claude_with_retry(
        client,
        model=config["model"],
        max_tokens=300,
        temperature=0.7,
        messages=[{"role": "user", "content": prompt}],
    )

    entry_text = response.content[0].text.strip()
    date_str = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    status_emoji = "+" if success else "x"

    entry = (
        f"## [{status_emoji}] #{issue.number} — {issue.title}\n"
        f"**{date_str}** | Files: {', '.join(changes.keys()) if changes else 'none'}\n\n"
        f"{entry_text}\n\n---\n\n"
    )

    print(f"Changelog entry generated: {entry_text[:100]}...")
    return entry


def write_changelog_entry(config, issue, changes: dict[str, str], success: bool, error: str | None = None):
    """Generate a changelog entry and write it to CHANGELOG.md (used for failure path)."""
    entry = generate_changelog_entry(config, issue, changes, success, error)

    changelog_path = os.path.join(REPO_DIR, "CHANGELOG.md")

    # Read existing content or start fresh
    header = "# CrowdPilot Changelog\n\nThe agent's autobiography — written by CrowdPilot after each build.\n\n---\n\n"
    if os.path.isfile(changelog_path):
        with open(changelog_path) as f:
            existing = f.read()
        # Insert new entry after the header
        if "---" in existing:
            parts = existing.split("---", 1)
            new_content = parts[0] + "---\n\n" + entry + parts[1].lstrip("\n")
        else:
            new_content = header + entry
    else:
        new_content = header + entry

    with open(changelog_path, "w") as f:
        f.write(new_content)


def vote_on_next_issue(repo, config, just_built_number: int):
    """After a build, the agent reviews the voting pool and votes on what to build next."""
    issues = repo.get_issues(state="open", labels=["voting"], sort="reactions-+1", direction="desc")
    issue_list = [i for i in issues if i.number != just_built_number]
    if not issue_list:
        print("No other voting issues to vote on.")
        return

    # Build a summary of the voting pool
    issue_summaries = []
    for i in issue_list:
        reactions = i.get_reactions().totalCount
        issue_summaries.append(f"- #{i.number}: {i.title} ({reactions} votes)\n  {i.body or '(no description)'}")

    prompt = (
        "You just finished a build. Now review the remaining issues in the voting pool "
        "and pick the ONE issue you think should be built next. Consider: feasibility, "
        "impact on the project, how interesting it would be for the community, and whether "
        "it builds on recent work.\n\n"
        "## Voting Pool\n\n" + "\n\n".join(issue_summaries) + "\n\n"
        "Respond with ONLY a JSON object (no markdown fencing):\n"
        '{"issue_number": <number>, "reason": "<1-2 sentence explanation>"}'
    )

    client = anthropic.Anthropic()
    response = call_claude_with_retry(
        client,
        model=config["model"],
        max_tokens=256,
        temperature=0,
        messages=[{"role": "user", "content": prompt}],
    )

    try:
        text = response.content[0].text.strip()
        # Strip markdown fencing if the model wraps the JSON
        if text.startswith("```"):
            text = text.split("\n", 1)[1] if "\n" in text else text[3:]
            text = text.rsplit("```", 1)[0].strip()
        vote = json.loads(text)
        chosen_number = vote["issue_number"]
        reason = vote["reason"]

        # Find the chosen issue and react + comment
        for i in issue_list:
            if i.number == chosen_number:
                i.create_reaction("+1")
                i.create_comment(
                    f"**CrowdPilot's vote:** I think this should be built next.\n\n"
                    f"_{reason}_"
                )
                print(f"Voted on issue #{chosen_number}: {reason}")
                return

        print(f"Agent chose issue #{chosen_number} but it wasn't found in the pool.")
    except Exception as e:
        print(f"Warning: Could not vote on next issue: {e}")
        print(f"Raw response: {response.content[0].text[:500] if response.content else '(empty)'}")


def run_git(*args):
    """Run a git command in the repo directory."""
    result = subprocess.run(
        ["git"] + list(args),
        cwd=REPO_DIR,
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        raise RuntimeError(f"git {' '.join(args)} failed: {result.stderr}")
    return result.stdout.strip()


# --- Retry Logic ---

def is_transient_error(error: Exception) -> bool:
    """Check if an error is transient (retryable)."""
    error_str = str(error).lower()
    
    # Rate limit errors
    if "rate_limit" in error_str or "429" in error_str:
        return True
    
    # Timeout errors
    if "timeout" in error_str or "timed out" in error_str:
        return True
    
    # Connection errors
    if "connection" in error_str or "network" in error_str:
        return True
    
    # Temporary service errors
    if "503" in error_str or "502" in error_str or "500" in error_str:
        return True
    
    # Anthropic-specific transient errors
    if hasattr(error, "status_code"):
        return error.status_code in [429, 500, 502, 503]
    
    return False


def call_claude_with_retry(
    client: anthropic.Anthropic,
    model: str,
    max_tokens: int,
    temperature: float,
    messages: list,
    system: str = None,
    tools: list = None,
    max_retries: int = MAX_RETRIES,
) -> anthropic.Message:
    """
    Call the Claude API with automatic retry logic for transient failures.
    
    Args:
        client: Anthropic client
        model: Model name
        max_tokens: Max tokens in response
        temperature: Temperature for sampling
        messages: Message history
        system: System prompt (optional)
        tools: Tool definitions (optional)
        max_retries: Maximum number of retries
    
    Returns:
        The API response
    
    Raises:
        anthropic.APIError: If all retries are exhausted
    """
    last_error = None
    
    for attempt in range(max_retries):
        try:
            kwargs = {
                "model": model,
                "max_tokens": max_tokens,
                "temperature": temperature,
                "messages": messages,
            }
            if system:
                kwargs["system"] = system
            if tools:
                kwargs["tools"] = tools
            
            response = client.messages.create(**kwargs)
            return response
        
        except Exception as e:
            last_error = e
            
            if not is_transient_error(e):
                # Non-transient error — fail immediately
                print(f"Non-transient error: {e}")
                raise
            
            if attempt < max_retries - 1:
                # Exponential backoff: 2s, 4s, 8s, etc.
                wait_time = RETRY_DELAY * (2 ** attempt)
                print(f"Transient error (attempt {attempt + 1}/{max_retries}): {e}")
                print(f"Retrying in {wait_time}s...")
                time.sleep(wait_time)
            else:
                # All retries exhausted
                print(f"All {max_retries} retries exhausted. Last error: {e}")
    
    # Should not reach here, but raise the last error if we do
    raise last_error


# --- Agent Loop ---

def build_prompt(issue, repo_files: list[str]) -> str:
    """Build the user prompt for the agent including issue and repo context."""
    parts = [
        f"## Task\n\nImplement the following GitHub issue:\n\n"
        f"**#{issue.number}: {issue.title}**\n\n{issue.body or '(no description)'}\n\n",
        "## Repository Structure\n\n",
    ]
    for path in repo_files:
        parts.append(f"- `{path}`\n")
    parts.append(
        "\n\nUse the `read_file` tool to examine any files you need. "
        "Use the `write_file` tool to make your changes. "
        "Use `list_files` to explore directories.\n\n"
        "When you are done making all changes, respond with a summary of what you did."
    )
    return "".join(parts)

def get_repo_file_list() -> list[str]:
    """Get a list of tracked files in the repo."""
    try:
        output = run_git("ls-files")
        return [f for f in output.split("\n") if f]
    except Exception:
        return []

def run_agent(issue, repo_files: list[str], config: dict, system_prompt: str) -> dict[str, str]:
    """
    Run the agent loop: call Claude with tools until done. Returns file changes.
    
    Includes:
    - Retry logic for Claude API calls
    - Graceful error handling for tool execution
    - Overall timeout for the agent loop
    """
    reset_file_changes()
    client = anthropic.Anthropic()
    
    start_time = time.time()

    messages = [
        {"role": "user", "content": build_prompt(issue, repo_files)}
    ]

    for turn in range(config["max_turns"]):
        # Check overall timeout
        elapsed = time.time() - start_time
        if elapsed > AGENT_LOOP_TIMEOUT:
            raise RuntimeError(
                f"Agent loop timeout exceeded ({AGENT_LOOP_TIMEOUT}s). "
                f"Completed {turn} turns before timeout."
            )
        
        print(f"--- Agent turn {turn + 1}/{config['max_turns']} (elapsed: {elapsed:.1f}s) ---")

        try:
            response = call_claude_with_retry(
                client,
                model=config["model"],
                max_tokens=config["max_tokens"],
                temperature=config["temperature"],
                system=system_prompt,
                messages=messages,
                tools=TOOL_DEFINITIONS,
            )
        except Exception as e:
            raise RuntimeError(f"Claude API call failed after retries: {e}")

        # Collect assistant content
        assistant_content = response.content
        messages.append({"role": "assistant", "content": assistant_content})

        # Check if done
        if response.stop_reason == "end_turn":
            # Extract final text
            for block in assistant_content:
                if hasattr(block, "text"):
                    print(f"Agent summary: {block.text[:200]}...")
            break

        # Process tool calls with error handling
        tool_results = []
        for block in assistant_content:
            if block.type == "tool_use":
                tool_name = block.name
                tool_input = block.input
                print(f"  Tool call: {tool_name}({json.dumps(tool_input)[:100]})")
                
                try:
                    result = execute_tool(tool_name, tool_input)
                    print(f"  Result: {result[:100]}...")
                    tool_results.append({
                        "type": "tool_result",
                        "tool_use_id": block.id,
                        "content": result,
                    })
                except Exception as e:
                    # Gracefully report tool execution error
                    error_msg = f"Tool execution error: {e}"
                    print(f"  Error: {error_msg}")
                    tool_results.append({
                        "type": "tool_result",
                        "tool_use_id": block.id,
                        "content": error_msg,
                        "is_error": True,
                    })

        if tool_results:
            messages.append({"role": "user", "content": tool_results})
    else:
        print("Agent reached max turns without finishing.")

    return get_file_changes()


# --- Main ---

def main():
    print("=== CrowdPilot Nightly Build ===")
    print(f"Time: {datetime.now(timezone.utc).isoformat()}")

    config = load_config()
    system_prompt = load_system_prompt()
    memory = load_memory()

    gh = get_github()
    repo = get_repo(gh)

    issue = None
    try:
        # Step 1: Find the winning issue
        issue = find_winning_issue(repo)
        if issue is None:
            print("No issues to build. Exiting.")
            return

        # Step 2: Announce the build
        announce_build(repo, issue)

        # Tweet about the build starting
        try:
            owner = os.environ.get("REPO_OWNER", "trevorstenson")
            name = os.environ.get("REPO_NAME", "crowd-agent")
            dry_run = os.environ.get("TWITTER_DRY_RUN", "").lower() == "true"
            tweet_build_start(issue.title, issue.number, owner, name, dry_run=dry_run)
        except Exception as e:
            print(f"Warning: Could not tweet build start: {e}")

        # Step 3: Get repo context
        repo_files = get_repo_file_list()

        # Step 4-5: Run the agent loop (calls Claude, executes tools)
        changes = run_agent(issue, repo_files, config, system_prompt)

        if not changes:
            raise RuntimeError("Agent made no file changes.")

        # Step 6: Generate changelog entry (embedded in PR, written on merge)
        changelog_text = ""
        try:
            changelog_text = generate_changelog_entry(config, issue, changes, success=True)
        except Exception as e:
            print(f"Warning: Could not generate changelog: {e}")

        # Step 7: Create branch and PR (with changelog embedded in body)
        pr_url = create_branch_and_pr(repo, issue, changes, changelog_text=changelog_text)

        # Step 8: Report the result
        report_result(issue, pr_url)

        # Tweet about the build result
        try:
            dry_run = os.environ.get("TWITTER_DRY_RUN", "").lower() == "true"
            tweet_build_success(issue.title, pr_url, dry_run=dry_run)
        except Exception as e:
            print(f"Warning: Could not tweet build success: {e}")

        # Step 9: Vote on what to build next
        try:
            vote_on_next_issue(repo, config, issue.number)
        except Exception as e:
            print(f"Warning: Could not vote on next issue: {e}")

        print("Build completed successfully!")

    except Exception as e:
        print(f"Build failed: {e}")
        memory["total_builds"] += 1
        memory["failed_builds"] += 1
        memory["streak"] = 0
        memory["last_build_date"] = datetime.now(timezone.utc).isoformat()
        save_memory(memory)

        # Write changelog entry for the failure
        if issue:
            try:
                write_changelog_entry(config, issue, {}, success=False, error=str(e))
            except Exception as changelog_err:
                print(f"Warning: Could not write changelog: {changelog_err}")

        try:
            report_failure(repo, issue, str(e))
        except Exception as report_err:
            print(f"Failed to report failure: {report_err}")

        # Tweet about the build failure
        if issue:
            try:
                owner = os.environ.get("REPO_OWNER", "trevorstenson")
                name = os.environ.get("REPO_NAME", "crowd-agent")
                dry_run = os.environ.get("TWITTER_DRY_RUN", "").lower() == "true"
                tweet_build_failure(issue.title, issue.number, owner, name, dry_run=dry_run)
            except Exception as twit_err:
                print(f"Warning: Could not tweet build failure: {twit_err}")

        sys.exit(1)


if __name__ == "__main__":
    main()
