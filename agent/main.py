"""
CrowdPilot Agent — The Evolving Build Loop

This script runs nightly via GitHub Actions. It:
1. Finds the top-voted issue labeled 'voting'
2. Announces the build on the issue
3. Calls the Claude API with tool use to implement the feature
4. Creates a branch and PR with the changes
5. Reports the result

This file is community-modifiable — the community can vote to change
how the agent works, what tools it has, and how it makes decisions.
"""

import json
import os
import subprocess
import sys
from datetime import datetime, timezone

import anthropic
from github import Auth, Github

from tools import (
    TOOL_DEFINITIONS,
    execute_tool,
    get_file_changes,
    reset_file_changes,
)

# --- Configuration ---

REPO_DIR = os.environ.get("GITHUB_WORKSPACE", os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

def load_config() -> dict:
    config_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "config.json")
    with open(config_path) as f:
        return json.load(f)

def load_system_prompt() -> str:
    prompt_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "prompt.md")
    with open(prompt_path) as f:
        return f.read()

def load_memory() -> dict:
    memory_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "memory.json")
    with open(memory_path) as f:
        return json.load(f)

def save_memory(memory: dict):
    memory_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), "memory.json")
    with open(memory_path, "w") as f:
        json.dump(memory, f, indent=2)
        f.write("\n")


# --- GitHub Helpers ---

def get_github() -> Github:
    token = os.environ["GITHUB_TOKEN"]
    return Github(auth=Auth.Token(token))

def get_repo(gh: Github):
    owner = os.environ.get("REPO_OWNER", "trevorstenson")
    name = os.environ.get("REPO_NAME", "crowd-agent")
    return gh.get_repo(f"{owner}/{name}")

def find_winning_issue(repo):
    """Find the open issue with the most thumbs-up reactions labeled 'voting'."""
    issues = repo.get_issues(state="open", labels=["voting"], sort="reactions-+1", direction="desc")
    issue_list = list(issues)
    if not issue_list:
        print("No issues with 'voting' label found. Nothing to build.")
        return None

    # Sort by thumbs-up reactions (GitHub API sort may not be exact)
    best = max(issue_list, key=lambda i: i.get_reactions().totalCount)
    print(f"Winning issue #{best.number}: {best.title} ({best.get_reactions().totalCount} reactions)")
    return best

def announce_build(repo, issue):
    """Comment on the issue and relabel from 'voting' to 'building'."""
    issue.create_comment("I'm building this now. Watch this space for a PR link.")
    # Relabel
    try:
        issue.remove_from_labels("voting")
    except Exception:
        pass
    issue.add_to_labels("building")

def create_branch_and_pr(repo, issue, changes: dict[str, str]) -> str:
    """Create a branch, commit changes, push, and open a PR. Returns PR URL."""
    branch_name = f"agent/issue-{issue.number}"
    base_branch = repo.default_branch

    # Git operations
    run_git("config", "user.name", "CrowdPilot[bot]")
    run_git("config", "user.email", "crowdpilot-bot@users.noreply.github.com")
    # Delete branch if it already exists locally, then create fresh
    try:
        run_git("branch", "-D", branch_name)
    except RuntimeError:
        pass
    run_git("checkout", "-b", branch_name)

    # Stage all changed files
    for path in changes:
        run_git("add", path)

    commit_msg = f"feat: implement #{issue.number} — {issue.title}"
    run_git("commit", "-m", commit_msg)

    # Push using the GITHUB_TOKEN
    token = os.environ["GITHUB_TOKEN"]
    owner = os.environ.get("REPO_OWNER", "trevorstenson")
    name = os.environ.get("REPO_NAME", "crowd-agent")
    remote_url = f"https://x-access-token:{token}@github.com/{owner}/{name}.git"
    run_git("remote", "set-url", "origin", remote_url)
    run_git("push", "--force", "--set-upstream", "origin", branch_name)

    # Create PR
    pr_body = (
        f"Closes #{issue.number}\n\n"
        f"**Issue:** {issue.title}\n\n"
        f"This PR was automatically generated by CrowdPilot.\n\n"
        f"**Files changed:** {', '.join(changes.keys())}\n\n"
        f"Please review and approve to merge."
    )
    pr = repo.create_pull(
        title=commit_msg,
        body=pr_body,
        head=branch_name,
        base=base_branch,
    )
    print(f"Created PR #{pr.number}: {pr.html_url}")
    return pr.html_url

def report_result(issue, pr_url: str):
    """Comment on the issue with the PR link."""
    issue.create_comment(f"Build complete! PR ready for review: {pr_url}")
    # Relabel
    try:
        issue.remove_from_labels("building")
    except Exception:
        pass
    issue.add_to_labels("review")

def report_failure(repo, issue, error: str):
    """Handle build failure."""
    if issue:
        issue.create_comment(f"Build failed. Error:\n```\n{error}\n```")
        try:
            issue.remove_from_labels("building")
        except Exception:
            pass
        issue.add_to_labels("voting")
    else:
        # No issue context — open a failure issue
        repo.create_issue(
            title="Agent build failure",
            body=f"The nightly build failed with no active issue.\n\nError:\n```\n{error}\n```",
            labels=["bug"],
        )

def run_git(*args):
    """Run a git command in the repo directory."""
    result = subprocess.run(
        ["git"] + list(args),
        cwd=REPO_DIR,
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        raise RuntimeError(f"git {' '.join(args)} failed: {result.stderr}")
    return result.stdout.strip()


# --- Agent Loop ---

def build_prompt(issue, repo_files: list[str]) -> str:
    """Build the user prompt for the agent including issue and repo context."""
    parts = [
        f"## Task\n\nImplement the following GitHub issue:\n\n"
        f"**#{issue.number}: {issue.title}**\n\n{issue.body or '(no description)'}\n\n",
        "## Repository Structure\n\n",
    ]
    for path in repo_files:
        parts.append(f"- `{path}`\n")
    parts.append(
        "\n\nUse the `read_file` tool to examine any files you need. "
        "Use the `write_file` tool to make your changes. "
        "Use `list_files` to explore directories.\n\n"
        "When you are done making all changes, respond with a summary of what you did."
    )
    return "".join(parts)

def get_repo_file_list() -> list[str]:
    """Get a list of tracked files in the repo."""
    try:
        output = run_git("ls-files")
        return [f for f in output.split("\n") if f]
    except Exception:
        return []

def run_agent(issue, repo_files: list[str], config: dict, system_prompt: str) -> dict[str, str]:
    """Run the agent loop: call Claude with tools until done. Returns file changes."""
    reset_file_changes()
    client = anthropic.Anthropic()

    messages = [
        {"role": "user", "content": build_prompt(issue, repo_files)}
    ]

    for turn in range(config["max_turns"]):
        print(f"--- Agent turn {turn + 1}/{config['max_turns']} ---")

        response = client.messages.create(
            model=config["model"],
            max_tokens=config["max_tokens"],
            temperature=config["temperature"],
            system=system_prompt,
            messages=messages,
            tools=TOOL_DEFINITIONS,
        )

        # Collect assistant content
        assistant_content = response.content
        messages.append({"role": "assistant", "content": assistant_content})

        # Check if done
        if response.stop_reason == "end_turn":
            # Extract final text
            for block in assistant_content:
                if hasattr(block, "text"):
                    print(f"Agent summary: {block.text[:200]}...")
            break

        # Process tool calls
        tool_results = []
        for block in assistant_content:
            if block.type == "tool_use":
                print(f"  Tool call: {block.name}({json.dumps(block.input)[:100]})")
                result = execute_tool(block.name, block.input)
                print(f"  Result: {result[:100]}...")
                tool_results.append({
                    "type": "tool_result",
                    "tool_use_id": block.id,
                    "content": result,
                })

        if tool_results:
            messages.append({"role": "user", "content": tool_results})
    else:
        print("Agent reached max turns without finishing.")

    return get_file_changes()


# --- Main ---

def main():
    print("=== CrowdPilot Nightly Build ===")
    print(f"Time: {datetime.now(timezone.utc).isoformat()}")

    config = load_config()
    system_prompt = load_system_prompt()
    memory = load_memory()

    gh = get_github()
    repo = get_repo(gh)

    issue = None
    try:
        # Step 1: Find the winning issue
        issue = find_winning_issue(repo)
        if issue is None:
            print("No issues to build. Exiting.")
            return

        # Step 2: Announce the build
        announce_build(repo, issue)

        # Step 3: Get repo context
        repo_files = get_repo_file_list()

        # Step 4-5: Run the agent loop (calls Claude, executes tools)
        changes = run_agent(issue, repo_files, config, system_prompt)

        if not changes:
            raise RuntimeError("Agent made no file changes.")

        # Step 6: Create branch and PR
        pr_url = create_branch_and_pr(repo, issue, changes)

        # Step 7: Report the result
        report_result(issue, pr_url)

        # Update memory
        memory["total_builds"] += 1
        memory["successful_builds"] += 1
        memory["last_build_date"] = datetime.now(timezone.utc).isoformat()
        memory["streak"] += 1
        save_memory(memory)

        # Commit memory update to main
        try:
            run_git("checkout", repo.default_branch)
            run_git("add", "agent/memory.json")
            run_git("commit", "-m", "chore: update agent memory")
            run_git("push")
        except Exception as e:
            print(f"Warning: Could not commit memory update: {e}")

        print("Build completed successfully!")

    except Exception as e:
        print(f"Build failed: {e}")
        memory["total_builds"] += 1
        memory["failed_builds"] += 1
        memory["streak"] = 0
        memory["last_build_date"] = datetime.now(timezone.utc).isoformat()
        save_memory(memory)

        try:
            report_failure(repo, issue, str(e))
        except Exception as report_err:
            print(f"Failed to report failure: {report_err}")

        sys.exit(1)


if __name__ == "__main__":
    main()
